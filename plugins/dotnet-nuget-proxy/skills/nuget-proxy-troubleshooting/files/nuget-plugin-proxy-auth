#!/usr/bin/env python3
"""
NuGet Proxy Credential Provider - Self-contained proxy + NuGet plugin.

Solves the problem where NuGet doesn't pass PROXY_AUTHORIZATION to the
downstream proxy, causing 401 errors during package restore.

This single file:
  1. Embeds an HTTP/HTTPS proxy that injects JWT auth into upstream requests
  2. Manages the proxy lifecycle (start/stop/health check)
  3. Implements the NuGet cross-platform plugin protocol v2
  4. When NuGet invokes this plugin, it ensures the proxy is running first

After installation, `dotnet restore` works without wrapper scripts or
NuGet.Config changes. The install script sets:
  - NUGET_PLUGIN_PATHS  -> points to this file
  - HTTPS_PROXY         -> http://127.0.0.1:8888 (the local proxy)

Usage:
  nuget-plugin-proxy-auth -Plugin    # NuGet invokes this automatically
  nuget-plugin-proxy-auth --start    # Start the proxy daemon manually
  nuget-plugin-proxy-auth --stop     # Stop the proxy daemon
  nuget-plugin-proxy-auth --status   # Show proxy and environment status
"""

import base64
import http.server
import json
import os
import select
import signal
import socket
import subprocess
import sys
import time
import urllib.error
import urllib.parse
import urllib.request
import uuid
from socketserver import ThreadingMixIn

# =============================================================================
# Configuration
# =============================================================================

PLUGIN_NAME = "NuGetProxyCredentialProvider"
PROTOCOL_VERSION = "2.0.0"
LOCAL_PROXY_PORT = 8888
LOCAL_PROXY_HOST = "127.0.0.1"
LOCAL_PROXY_URL = f"http://{LOCAL_PROXY_HOST}:{LOCAL_PROXY_PORT}"
PID_FILE = "/tmp/nuget-proxy.pid"
LOG_FILE = "/tmp/nuget-proxy.log"

# NuGet plugin protocol constants
OPERATION_AUTHENTICATION = 2
RESPONSE_SUCCESS = "Success"
RESPONSE_NOT_FOUND = "NotFound"


# =============================================================================
# Environment / Credential Helpers
# =============================================================================

def log(message):
    """Write diagnostic messages to stderr (never secrets)."""
    print(f"[{PLUGIN_NAME}] {message}", file=sys.stderr, flush=True)


def get_upstream_proxy_url():
    """
    Get the upstream (authenticated) proxy URL from environment.

    When this plugin is invoked by NuGet, HTTPS_PROXY will be set to
    localhost:8888 (the local proxy). We need the ORIGINAL upstream proxy.
    Check _UPSTREAM_PROXY first (set by install script), then fall back
    to the standard env vars only if they don't point to localhost.
    """
    # The install script saves the original upstream proxy here
    upstream = os.environ.get("_NUGET_UPSTREAM_PROXY", "").strip()
    if upstream:
        return upstream

    # Fall back: check standard env vars, skip if they point to our local proxy
    for var in ("HTTPS_PROXY", "https_proxy", "HTTP_PROXY", "http_proxy"):
        url = os.environ.get(var, "").strip()
        if url and LOCAL_PROXY_HOST not in url and "127.0.0.1" not in url and "localhost" not in url:
            return url

    return None


def get_proxy_credentials():
    """
    Extract proxy credentials from the environment.

    Returns: (username, password) or (None, None)
    """
    # Method 1: PROXY_AUTHORIZATION env var
    proxy_auth = os.environ.get("PROXY_AUTHORIZATION", "").strip()
    if proxy_auth:
        if proxy_auth.startswith("Basic "):
            try:
                decoded = base64.b64decode(proxy_auth[6:]).decode("utf-8")
                if ":" in decoded:
                    return decoded.split(":", 1)
            except Exception:
                pass
            return "proxy-auth", proxy_auth
        if proxy_auth.startswith("Bearer "):
            return "proxy-auth", proxy_auth
        return "proxy-auth", proxy_auth

    # Method 2: Credentials embedded in upstream proxy URL
    upstream = get_upstream_proxy_url()
    if upstream:
        try:
            parsed = urllib.parse.urlparse(upstream)
            if parsed.username:
                return (
                    urllib.parse.unquote(parsed.username),
                    urllib.parse.unquote(parsed.password or ""),
                )
        except Exception:
            pass

    return None, None


# =============================================================================
# Embedded Proxy Server
# =============================================================================

class _ProxyHandler(http.server.BaseHTTPRequestHandler):
    """HTTP/HTTPS proxy that injects JWT auth into upstream proxy requests."""

    timeout = 60
    upstream_host = None
    upstream_port = None
    upstream_auth = None
    upstream_url = None

    def do_CONNECT(self):
        try:
            host, port = self.path.split(":")
            port = int(port)
            proxy_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            proxy_sock.settimeout(30)
            proxy_sock.connect((self.upstream_host, self.upstream_port))

            connect_req = f"CONNECT {host}:{port} HTTP/1.1\r\nHost: {host}:{port}\r\n"
            if self.upstream_auth:
                connect_req += f"Proxy-Authorization: Basic {self.upstream_auth}\r\n"
            connect_req += "\r\n"
            proxy_sock.sendall(connect_req.encode())

            response = b""
            while b"\r\n\r\n" not in response:
                chunk = proxy_sock.recv(4096)
                if not chunk:
                    break
                response += chunk

            if b"200" in response.split(b"\r\n")[0]:
                self.send_response(200, "Connection Established")
                self.send_header("Proxy-agent", "NuGet-Proxy")
                self.end_headers()
                self._tunnel(self.connection, proxy_sock)
            else:
                self.send_error(502, "Bad Gateway - Upstream proxy refused")
        except Exception as e:
            self.send_error(502, f"Bad Gateway: {e}")

    def _tunnel(self, client_sock, proxy_sock):
        try:
            sockets = [client_sock, proxy_sock]
            while True:
                readable, _, exceptional = select.select(sockets, [], sockets, 60)
                if exceptional or not readable:
                    break
                for sock in readable:
                    try:
                        data = sock.recv(8192)
                        if not data:
                            return
                        if sock is client_sock:
                            proxy_sock.sendall(data)
                        else:
                            client_sock.sendall(data)
                    except Exception:
                        return
        except Exception:
            pass
        finally:
            try:
                proxy_sock.close()
            except Exception:
                pass

    def do_GET(self):
        self._proxy_request()

    def do_POST(self):
        self._proxy_request()

    def do_HEAD(self):
        self._proxy_request()

    def do_PUT(self):
        self._proxy_request()

    def _proxy_request(self):
        try:
            url = self.path if self.path.startswith("http") else f"http://{self.headers['Host']}{self.path}"
            content_length = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_length) if content_length > 0 else None
            req = urllib.request.Request(url, data=body, method=self.command)
            for key, value in self.headers.items():
                if key.lower() not in ("host", "connection", "proxy-connection"):
                    req.add_header(key, value)
            proxy_handler = urllib.request.ProxyHandler({"http": self.upstream_url, "https": self.upstream_url})
            opener = urllib.request.build_opener(proxy_handler)
            response = opener.open(req, timeout=30)
            self.send_response(response.status)
            for key, value in response.headers.items():
                self.send_header(key, value)
            self.end_headers()
            self.wfile.write(response.read())
        except urllib.error.HTTPError as e:
            self.send_response(e.code)
            self.end_headers()
            if e.fp:
                self.wfile.write(e.fp.read())
        except Exception as e:
            self.send_response(502)
            self.end_headers()
            self.wfile.write(f"Proxy Error: {e}".encode())

    def log_message(self, format, *args):
        pass  # Quiet logging when run as daemon


class _ThreadedHTTPServer(ThreadingMixIn, http.server.HTTPServer):
    daemon_threads = True
    allow_reuse_address = True


# =============================================================================
# Proxy Lifecycle Management
# =============================================================================

def is_proxy_running():
    """Check if the local proxy is running on LOCAL_PROXY_PORT."""
    # Check PID file first
    if os.path.exists(PID_FILE):
        try:
            with open(PID_FILE) as f:
                pid = int(f.read().strip())
            os.kill(pid, 0)  # Check if process exists
            return True
        except (ValueError, ProcessLookupError, PermissionError):
            pass

    # Fall back: check if port is listening
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        result = sock.connect_ex((LOCAL_PROXY_HOST, LOCAL_PROXY_PORT))
        sock.close()
        return result == 0
    except Exception:
        return False


def start_proxy_daemon():
    """
    Start the proxy as a background daemon process.

    Spawns a new instance of THIS SCRIPT with --_run-proxy, which runs the
    proxy server in the foreground. The daemon is detached from the parent.
    """
    if is_proxy_running():
        log("Proxy already running")
        return True

    upstream = get_upstream_proxy_url()
    if not upstream:
        log("ERROR: No upstream proxy URL found in environment")
        return False

    log(f"Starting proxy daemon on {LOCAL_PROXY_URL}")

    # Spawn self as daemon with --_run-proxy flag
    script_path = os.path.abspath(__file__)
    env = os.environ.copy()
    env["_NUGET_UPSTREAM_PROXY"] = upstream

    with open(LOG_FILE, "a") as log_f:
        proc = subprocess.Popen(
            [sys.executable, script_path, "--_run-proxy"],
            stdout=log_f,
            stderr=log_f,
            stdin=subprocess.DEVNULL,
            env=env,
            start_new_session=True,  # Detach from parent
        )

    # Write PID file
    with open(PID_FILE, "w") as f:
        f.write(str(proc.pid))

    # Wait for proxy to be ready
    for _ in range(20):
        time.sleep(0.25)
        if is_proxy_running():
            log(f"Proxy started (PID {proc.pid})")
            return True

    log("ERROR: Proxy failed to start within 5 seconds")
    return False


def stop_proxy():
    """Stop the proxy daemon."""
    if os.path.exists(PID_FILE):
        try:
            with open(PID_FILE) as f:
                pid = int(f.read().strip())
            os.kill(pid, signal.SIGTERM)
            os.remove(PID_FILE)
            print(f"Proxy stopped (PID {pid})")
            return True
        except (ValueError, ProcessLookupError):
            os.remove(PID_FILE)
    print("Proxy is not running")
    return False


def run_proxy_server():
    """Run the proxy server in the foreground (used by daemon subprocess)."""
    upstream = get_upstream_proxy_url()
    if not upstream:
        print("ERROR: No upstream proxy URL found", file=sys.stderr)
        sys.exit(1)

    parsed = urllib.parse.urlparse(upstream)
    _ProxyHandler.upstream_host = parsed.hostname
    _ProxyHandler.upstream_port = parsed.port or 8080
    _ProxyHandler.upstream_url = upstream
    _ProxyHandler.upstream_auth = None

    if parsed.username:
        auth_string = f"{urllib.parse.unquote(parsed.username)}:{urllib.parse.unquote(parsed.password or '')}"
        _ProxyHandler.upstream_auth = base64.b64encode(auth_string.encode()).decode()

    server = _ThreadedHTTPServer((LOCAL_PROXY_HOST, LOCAL_PROXY_PORT), _ProxyHandler)
    print(f"NuGet proxy running on {LOCAL_PROXY_URL}", flush=True)

    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass
    finally:
        server.shutdown()


# =============================================================================
# NuGet Plugin Protocol v2
# =============================================================================

def make_response(request_id, method, payload):
    return {
        "RequestId": request_id,
        "Type": "Response",
        "Method": method,
        "Payload": payload,
    }


def handle_handshake(request_id, payload):
    return make_response(request_id, "Handshake", {
        "ResponseCode": RESPONSE_SUCCESS,
        "ProtocolVersion": PROTOCOL_VERSION,
    })


def handle_initialize(request_id, payload):
    return make_response(request_id, "Initialize", {
        "ResponseCode": RESPONSE_SUCCESS,
    })


def handle_get_operation_claims(request_id, payload):
    return make_response(request_id, "GetOperationClaims", {
        "ResponseCode": RESPONSE_SUCCESS,
        "Claims": [OPERATION_AUTHENTICATION],
    })


def handle_get_authentication_credentials(request_id, payload):
    username, password = get_proxy_credentials()
    if username and password:
        return make_response(request_id, "GetAuthenticationCredentials", {
            "ResponseCode": RESPONSE_SUCCESS,
            "Username": username,
            "Password": password,
            "AuthTypes": ["Basic"],
            "Message": "",
        })
    return make_response(request_id, "GetAuthenticationCredentials", {
        "ResponseCode": RESPONSE_NOT_FOUND,
        "Username": "",
        "Password": "",
        "AuthTypes": [],
        "Message": "No proxy credentials found in environment",
    })


def handle_set_credentials(request_id, payload):
    return make_response(request_id, "SetCredentials", {
        "ResponseCode": RESPONSE_SUCCESS,
    })


HANDLERS = {
    "Handshake": handle_handshake,
    "Initialize": handle_initialize,
    "GetOperationClaims": handle_get_operation_claims,
    "GetAuthenticationCredentials": handle_get_authentication_credentials,
    "SetCredentials": handle_set_credentials,
    "GetServiceIndex": lambda rid, _: make_response(rid, "GetServiceIndex", {"ResponseCode": RESPONSE_NOT_FOUND}),
    "Log": lambda rid, _: make_response(rid, "Log", {"ResponseCode": RESPONSE_SUCCESS}),
}


def run_plugin():
    """
    NuGet plugin entry point.

    1. Ensures the local proxy is running (starts it if not)
    2. Handles the NuGet plugin protocol over stdin/stdout
    """
    log("Plugin starting")

    # Ensure the proxy is running before NuGet makes any requests
    if not is_proxy_running():
        log("Proxy not running, starting daemon...")
        if not start_proxy_daemon():
            log("WARNING: Failed to start proxy daemon")
    else:
        log("Proxy already running")

    log("Handling NuGet plugin protocol")

    try:
        for line in sys.stdin:
            line = line.strip()
            if not line:
                continue
            try:
                message = json.loads(line)
            except json.JSONDecodeError:
                continue

            if message.get("Type") != "Request":
                continue

            method = message.get("Method", "")
            request_id = message.get("RequestId", str(uuid.uuid4()))
            payload = message.get("Payload", {})

            handler = HANDLERS.get(method)
            if handler:
                response = handler(request_id, payload)
            else:
                response = make_response(request_id, method, {"ResponseCode": RESPONSE_NOT_FOUND})

            sys.stdout.write(json.dumps(response) + "\n")
            sys.stdout.flush()
    except (KeyboardInterrupt, BrokenPipeError):
        pass
    finally:
        log("Plugin exiting (proxy daemon stays running)")


# =============================================================================
# CLI Interface
# =============================================================================

def print_status():
    """Show proxy and environment status."""
    print(f"{PLUGIN_NAME}")
    print(f"{'=' * len(PLUGIN_NAME)}")
    print()

    # Proxy status
    running = is_proxy_running()
    status = "RUNNING" if running else "STOPPED"
    print(f"  Local proxy:    {LOCAL_PROXY_URL}  [{status}]")

    if os.path.exists(PID_FILE):
        try:
            with open(PID_FILE) as f:
                print(f"  Proxy PID:      {f.read().strip()}")
        except Exception:
            pass

    # Upstream proxy
    upstream = get_upstream_proxy_url()
    if upstream:
        parsed = urllib.parse.urlparse(upstream)
        print(f"  Upstream proxy: {parsed.scheme}://{parsed.hostname}:{parsed.port}")
    else:
        print("  Upstream proxy: (not detected)")

    # Credentials
    username, _ = get_proxy_credentials()
    print(f"  Credentials:    {'available' if username else 'NOT FOUND'}")

    auth = os.environ.get("PROXY_AUTHORIZATION", "")
    if auth:
        kind = "Basic" if auth.startswith("Basic ") else "Bearer" if auth.startswith("Bearer ") else "Raw token"
        print(f"  Auth type:      {kind}")

    # Plugin paths
    plugin_paths = os.environ.get("NUGET_PLUGIN_PATHS", "")
    print(f"  Plugin paths:   {plugin_paths or '(not set)'}")

    print()
    print("Commands:")
    print(f"  {os.path.basename(__file__)} --start    Start proxy daemon")
    print(f"  {os.path.basename(__file__)} --stop     Stop proxy daemon")
    print(f"  {os.path.basename(__file__)} --status   Show this status")
    print(f"  {os.path.basename(__file__)} -Plugin    NuGet plugin mode (auto)")


if __name__ == "__main__":
    args = sys.argv[1:]

    if "-Plugin" in args:
        run_plugin()
    elif "--_run-proxy" in args:
        run_proxy_server()
    elif "--start" in args:
        if start_proxy_daemon():
            print(f"Proxy running on {LOCAL_PROXY_URL}")
        else:
            print("Failed to start proxy", file=sys.stderr)
            sys.exit(1)
    elif "--stop" in args:
        stop_proxy()
    elif "--status" in args or not args:
        print_status()
